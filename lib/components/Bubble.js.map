{"version":3,"sources":["../../source/components/Bubble.js"],"names":["BubbleBase","props","_hasEventListeners","_handleScrollEventListener","action","rootElement","scrollableNode","_getFirstScrollableParent","addEventListener","_updatePosition","removeEventListener","element","node","hasOwnProperty","call","current","scrollHeight","clientHeight","parentElement","isOpeningUpward","targetRef","target","targetRect","getBoundingClientRect","positionY","window","innerHeight","top","bottom","position","width","positionX","left","setState","context","themeId","theme","themeOverrides","state","composedTheme","ROOT_THEME_API","setTimeout","isFloating","nextProps","bind","isHidden","_getDocumentEvents","prevProps","didVisibilityChange","wasBubbleHidden","_removeAllEventListeners","resize","scroll","skin","rest","BubbleSkin","skins","IDENTIFIERS","BUBBLE","Component","displayName","defaultProps","isTransparent","arrowRelativeToTip","Bubble"],"mappings":"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","file":"Bubble.js","sourcesContent":["// @flow\nimport React, { Component } from 'react';\nimport type { ComponentType, Element, ElementRef } from 'react';\nimport createRef from 'create-react-ref/lib/createRef';\n\n// internal utility functions\nimport { createEmptyContext, withTheme } from './HOC/withTheme';\nimport { composeTheme, addThemeId, didThemePropsChange } from '../utils/themes';\nimport { addDocumentListeners, removeDocumentListeners } from '../utils/events';\n\n// import constants\nimport { IDENTIFIERS } from '.';\nimport type { ThemeContextProp } from './HOC/withTheme';\n\ntype Props = {\n  className?: string,\n  context: ThemeContextProp,\n  isHidden: boolean,\n  isFloating: boolean,\n  isOpeningUpward: boolean,\n  isTransparent: boolean,\n  arrowRelativeToTip: boolean,\n  skin?: ComponentType<any>,\n  theme: ?Object, // takes precedence over them in context if passed\n  themeId: string,\n  themeOverrides: Object, // custom css/scss from user adhering to component's theme API\n  targetRef?: ElementRef<*>, // ref to the target DOM element used for positioning the bubble\n};\n\ntype State = {\n  composedTheme: Object,\n  position: ?Object\n};\n\nclass BubbleBase extends Component<Props, State> {\n  // declare ref types\n  rootElement: ?Element<any>;\n\n  // define static properties\n  static displayName = 'Bubble';\n  static defaultProps = {\n    context: createEmptyContext(),\n    isHidden: false,\n    isFloating: false,\n    isOpeningUpward: false,\n    isTransparent: true,\n    arrowRelativeToTip: false,\n    theme: null,\n    themeId: IDENTIFIERS.BUBBLE,\n    themeOverrides: {}\n  };\n\n  constructor(props: Props) {\n    super(props);\n\n    // define ref\n    this.rootElement = createRef();\n\n    const { context, themeId, theme, themeOverrides } = props;\n\n    this.state = {\n      composedTheme: composeTheme(\n        addThemeId(theme || context.theme, themeId),\n        addThemeId(themeOverrides, themeId),\n        context.ROOT_THEME_API\n      ),\n      position: null\n    };\n  }\n\n  _hasEventListeners = false;\n\n  componentDidMount() {\n    setTimeout(() => {\n      if (this.props.isFloating) this._updatePosition();\n    }, 0);\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    didThemePropsChange(this.props, nextProps, this.setState.bind(this));\n  }\n\n  componentWillUpdate(nextProps) {\n    const { isFloating } = this.props;\n    // Add listeners when the bubble\n    if (isFloating && !nextProps.isHidden && !this._hasEventListeners) {\n      this._handleScrollEventListener('add');\n      addDocumentListeners(this._getDocumentEvents());\n      window.addEventListener('resize', this._updatePosition);\n      this._hasEventListeners = true;\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    const { isHidden } = this.props;\n    const didVisibilityChange = isHidden !== prevProps.isHidden;\n    const wasBubbleHidden = !prevProps.isHidden && isHidden;\n\n    if (wasBubbleHidden) this._removeAllEventListeners();\n    if (didVisibilityChange) this._updatePosition();\n  }\n\n  componentWillUnmount() {\n    if (this._hasEventListeners) this._removeAllEventListeners();\n  }\n\n  // =========== PRIVATE HELPERS ==============\n\n  _handleScrollEventListener = (action: string) => {\n    // const rootNode = this.rootElement;\n    const { rootElement } = this;\n    if (rootElement) {\n      const scrollableNode = this._getFirstScrollableParent(rootElement);\n      if (scrollableNode) {\n        if (action === 'add') {\n          scrollableNode.addEventListener('scroll', this._updatePosition);\n        } else if (action === 'remove') {\n          scrollableNode.removeEventListener('scroll', this._updatePosition);\n        }\n      }\n    }\n  };\n\n  _removeAllEventListeners() {\n    if (this._hasEventListeners) {\n      removeDocumentListeners(this._getDocumentEvents());\n      this._handleScrollEventListener('remove');\n      window.removeEventListener('resize', this._updatePosition);\n      this._hasEventListeners = false;\n    }\n  }\n\n  _getFirstScrollableParent = (element: ElementRef<*>) => {\n    if (element == null) return null;\n    const { rootElement } = this;\n    const node = {}.hasOwnProperty.call(element, 'current') ? element.current : element;\n\n    if (rootElement) {\n      if (node === rootElement.current || node.scrollHeight <= node.clientHeight) {\n        return this._getFirstScrollableParent(node.parentElement);\n      }\n    }\n\n    return node;\n  };\n\n  _updatePosition = () => {\n    const { isOpeningUpward, targetRef } = this.props;\n    const { rootElement } = this;\n\n    let target = targetRef && typeof targetRef !== 'string' ? targetRef.current : null;\n\n    // Without a target, try to fallback to the parent node\n    if (!target) {\n      //  Only proceed if the root element is defined\n      if (!rootElement || !rootElement.current) return;\n      target = rootElement.current.parentElement;\n    }\n\n    const targetRect = target.getBoundingClientRect();\n\n    let positionY;\n    if (isOpeningUpward) {\n      // Since we don't know the height of the bubble before rendering it we positioning\n      // it with { bottom: XYpx } (within the viewport) and need this calculation:\n      positionY = window.innerHeight - targetRect.top + 20;\n    } else {\n      positionY = targetRect.bottom + 20;\n    }\n\n    const position = {\n      width: targetRect.width,\n      positionX: targetRect.left,\n      positionY\n    };\n    this.setState({ position });\n  };\n\n  _getDocumentEvents() {\n    return {\n      resize: this._updatePosition,\n      scroll: this._updatePosition\n    };\n  }\n\n  render() {\n    // destructuring props ensures only the \"...rest\" get passed down\n    const {\n      skin,\n      theme,\n      themeOverrides,\n      context,\n      ...rest\n    } = this.props;\n\n    const BubbleSkin = skin || context.skins[IDENTIFIERS.BUBBLE];\n\n    return (\n      <BubbleSkin\n        rootRef={this.rootElement}\n        position={this.state.position}\n        theme={this.state.composedTheme}\n        {...rest}\n      />\n    );\n  }\n}\n\nexport const Bubble = withTheme(BubbleBase);\n"]}