{"version":3,"sources":["../../source/components/NumericInput.js"],"names":["NumericInputBase","props","onChange","event","preventDefault","disabled","processedValue","_processValue","target","value","trim","selectionStart","state","oldValue","focus","inputElement","current","_setError","error","setError","setState","context","minValue","maxBeforeDot","maxAfterDot","themeId","theme","themeOverrides","minValueIsNum","_validateLimitProps","composedTheme","ROOT_THEME_API","caretPosition","separatorsCount","autoFocus","nextProps","bind","prevProps","prevState","document","activeElement","selectionEnd","maxBeforeDotIsNum","maxAfterDotIsNum","minValParts","parseFloat","toString","split","length","minValBeforeDot","minValAfterDot","Error","position","_enforceNumericValue","_parseToParts","_enforceValueLimits","_separate","call","regex","isValueRegular","test","handledValue","lastValidValue","_isNumeric","splitedValue","splitedOldValue","beforeDot","beforeDotWithoutComma","includes","beforeComma","slice","indexOf","afterComma","replace","lastInsertedCharacter","substring","data","afterDot","charAt","parseInt","parts","maxValue","enforceMax","enforceMin","valueWithDecimalRestrictions","_enforceDecimalRestrictions","valueWithoutSeparators","formattedMaxVal","toFixed","formattedMinVal","numberOfCommas","maxBeforeDotWithSeparator","afterDotLength","separatedValue","reverse","join","newSeparatorsCount","match","replacedValue","isNaN","isFinite","skin","rest","InputSkin","skins","IDENTIFIERS","INPUT","Component","displayName","defaultProps","readOnly","NumericInput"],"mappings":";;;;;;;;;;;;;;;AACA;;;;AAKA;;;;AAIA;;AACA;;AAGA;;;;;;;;;;;;AATA;;AAHA;;;AAOA;;;AAIA;;;IAsCMA,gB;;;AAIJ;AAaA,4BAAYC,KAAZ,EAA0B;AAAA;;AAAA,oIAClBA,KADkB;;AAAA,UAyE1BC,QAzE0B,GAyEf,UAACC,KAAD,EAAkD;AAC3DA,YAAMC,cAAN;AAD2D,wBAE5B,MAAKH,KAFuB;AAAA,UAEnDC,QAFmD,eAEnDA,QAFmD;AAAA,UAEzCG,QAFyC,eAEzCA,QAFyC;;AAG3D,UAAIA,QAAJ,EAAc;AAAE;AAAS;;AAEzB;AACA;AACA,UAAMC,iBAAiB,MAAKC,aAAL,CACrBJ,MAAMK,MAAN,CAAaC,KAAb,CAAmBC,IAAnB,EADqB,EAErBP,MAAMK,MAAN,CAAaG,cAFQ,CAAvB;;AAKA;AACA;AACA,UAAIL,mBAAmB,MAAKM,KAAL,CAAWC,QAAlC,EAA4C;AAAE;AAAS;;AAEvD,UAAIX,QAAJ,EAAc;AAAEA,iBAASI,cAAT,EAAyBH,KAAzB;AAAkC;AACnD,KA1FyB;;AAAA,UA4F1BW,KA5F0B,GA4FlB,YAAM;AAAA,UACJC,YADI,SACJA,YADI;;AAEZ,UAAI,CAACA,aAAaC,OAAlB,EAA2B;AAC3BD,mBAAaC,OAAb,CAAqBF,KAArB;AACD,KAhGyB;;AAAA,UAkI1BG,SAlI0B,GAkId,UAACC,KAAD,EAAmB;AAAA,UACrBC,QADqB,GACR,MAAKlB,KADG,CACrBkB,QADqB;;AAG7B;AACA;AACA;;AACA,UAAIA,QAAJ,EAAcA,SAASD,KAAT;AACd;AACA,YAAKE,QAAL,CAAc,EAAEF,YAAF,EAAd;AACD,KA3IyB;;AAAA,QAEhBG,OAFgB,GAEiEpB,KAFjE,CAEhBoB,OAFgB;AAAA,QAEPC,QAFO,GAEiErB,KAFjE,CAEPqB,QAFO;AAAA,QAEGC,YAFH,GAEiEtB,KAFjE,CAEGsB,YAFH;AAAA,QAEiBC,WAFjB,GAEiEvB,KAFjE,CAEiBuB,WAFjB;AAAA,QAE8BC,OAF9B,GAEiExB,KAFjE,CAE8BwB,OAF9B;AAAA,QAEuCC,KAFvC,GAEiEzB,KAFjE,CAEuCyB,KAFvC;AAAA,QAE8CC,cAF9C,GAEiE1B,KAFjE,CAE8C0B,cAF9C;;;AAIxB,QAAMC,gBAAgB,OAAON,QAAP,KAAoB,QAA1C;AACA;AACA,QAAIA,YAAYM,aAAZ,KAA8BL,gBAAgBC,WAA9C,CAAJ,EAAgE;AAC9D;AACA,YAAKK,mBAAL,CAAyBP,QAAzB,EAAmCC,YAAnC,EAAiDC,WAAjD;AACD;;AAED;AACA,UAAKT,YAAL,GAAoB,0BAApB;;AAEA,UAAKH,KAAL,GAAa;AACXkB,qBAAe,0BACb,wBAAWJ,SAASL,QAAQK,KAA5B,EAAmCD,OAAnC,CADa,EAEb,wBAAWE,cAAX,EAA2BF,OAA3B,CAFa,EAGbJ,QAAQU,cAHK,CADJ;AAMXC,qBAAe,CANJ;AAOXC,uBAAiB,CAPN;AAQXf,aAAO,EARI;AASXL,gBAAU;AATC,KAAb;AAdwB;AAyBzB;AAzCD;;;;;wCA2CoB;AAAA,UACVE,YADU,GACO,IADP,CACVA,YADU;AAElB;;AACA,UAAI,KAAKd,KAAL,CAAWiC,SAAf,EAA0B,KAAKpB,KAAL;;AAE1B;AACA,UAAIC,gBAAgBA,aAAaC,OAAjC,EAA0C;AACxC,aAAKI,QAAL,CAAc,EAAEY,eAAejB,aAAaC,OAAb,CAAqBL,cAAtC,EAAd;AACD;AACF;;;8CAEyBwB,S,EAAkB;AAC1C,uCAAoB,KAAKlC,KAAzB,EAAgCkC,SAAhC,EAA2C,KAAKf,QAAL,CAAcgB,IAAd,CAAmB,IAAnB,CAA3C;AACD;;;uCAEkBC,S,EAAkBC,S,EAAkB;AAAA,UAC7CvB,YAD6C,GAC5B,IAD4B,CAC7CA,YAD6C;;AAErD,UAAIA,gBAAgBA,aAAaC,OAAb,KAAyBuB,SAASC,aAAtD,EAAqE;AAAE;AAAS;;AAEhF;AACA,UAAIR,sBAAJ;AACA;AACA,UACE,KAAKpB,KAAL,CAAWC,QAAX,KAAwByB,UAAUzB,QAAlC,IACA,KAAKD,KAAL,CAAWoB,aAAX,KAA6BM,UAAUN,aAFzC,EAGE;AACA,YACE,KAAKpB,KAAL,CAAWqB,eAAX,KAA+BK,UAAUL,eAAzC,IACA,KAAKrB,KAAL,CAAWqB,eAAX,GAA6BK,UAAUL,eAAvC,IAA0D,CAD1D,IAEA,KAAKrB,KAAL,CAAWqB,eAAX,GAA6BK,UAAUL,eAAvC,IAA0D,CAAC,CAH7D,EAIE;AACAD,0BACE,KAAKpB,KAAL,CAAWoB,aAAX,IACC,KAAKpB,KAAL,CAAWqB,eAAX,GAA6BK,UAAUL,eADxC,CADF;AAGD,SARD,MAQO;AACLD,0BAAgB,KAAKpB,KAAL,CAAWoB,aAA3B;AACD;AACDA,wBAAgBA,iBAAiB,CAAjB,GAAqBA,aAArB,GAAqC,CAArD;;AAEA,YAAIjB,gBAAgBA,aAAaC,OAAjC,EAA0C;AACxCD,uBAAaC,OAAb,CAAqByB,YAArB,GAAoCT,aAApC;AACAjB,uBAAaC,OAAb,CAAqBL,cAArB,GAAsCqB,aAAtC;AACD;AACF;AACF;;;wCA2BmBV,Q,EAAmBC,Y,EAAuBC,W,EAAsB;AAClF,UAAI,OAAOF,QAAP,KAAoB,QAAxB,EAAkC;AAClC,UAAMoB,oBAAoB,OAAOnB,YAAP,KAAwB,QAAlD;AACA,UAAMoB,mBAAmB,OAAOnB,WAAP,KAAuB,QAAhD;AACA;AACA;AACA,UAAMoB,cAAcC,WAAWvB,QAAX,EAAqBwB,QAArB,GAAgCC,KAAhC,CAAsC,GAAtC,CAApB;;AAEA;AACA,UAAIH,YAAYI,MAAZ,IAAsB,CAA1B,EAA6B;AAC3B,YAAMC,kBAAkBL,YAAY,CAAZ,CAAxB;AACA,YAAMM,iBAAiBN,YAAY,CAAZ,CAAvB;;AAEA;AACA,YAAIrB,gBAAgBmB,iBAAhB,IAAsCO,gBAAgBD,MAAhB,GAAyBzB,YAAnE,EAAkF;AAChF;AACA,cAAML,oCACQI,QADR,4CACuDC,YADvD,kEAAN;AAIA,gBAAM,IAAI4B,KAAJ,CAAUjC,MAAV,CAAN;AACF;AACC,SARD,MAQO,IAAIM,eAAemB,gBAAf,IAAoCO,eAAeF,MAAf,GAAwBxB,WAAhE,EAA8E;AACnF,cAAMN,qCACQI,QADR,2CACsDE,WADtD,kEAAN;AAIA,gBAAM,IAAI2B,KAAJ,CAAUjC,OAAV,CAAN;AACD;AACF;AACF;;;kCAaaT,K,EAAe2C,Q,EAAkB;AAC7C,aAAO,oBAAK,CACV,KAAKC,oBADK,EAEV,KAAKC,aAFK,EAGV,KAAKC,mBAHK,EAIV,KAAKC,SAJK,CAAL,EAKJC,IALI,CAKC,IALD,EAKOhD,KALP,EAKc2C,QALd,CAAP;AAMD;;;yCAEoB3C,K,EAAe2C,Q,EAAkB;AACpD,UAAMM,QAAQ,YAAd;AACA,UAAMC,iBAAiBD,MAAME,IAAN,CAAWnD,KAAX,CAAvB;AAFoD,UAG5Cc,YAH4C,GAG3B,KAAKtB,KAHsB,CAG5CsB,YAH4C;;AAIpD,UAAIsC,qBAAJ;AACA,UAAMC,iBAAiB,KAAKlD,KAAL,CAAWC,QAAlC;AACA,UAAI,CAAC8C,cAAD,IAAmBlD,UAAU,EAAjC,EAAqC;AACnC;AACA;AACA;AACAoD,uBAAeC,kBAAkB,UAAjC;AACAV,oBAAY,CAAZ;AACD,OAND,MAMO,IAAI,CAAC,KAAKW,UAAL,CAAgBtD,KAAhB,CAAL,EAA6B;AAClC;AACA;AACA;AACA,YAAMuD,eAAevD,MAAMsC,KAAN,CAAY,GAAZ,CAArB;;AAEA;AACA,YAAIiB,aAAahB,MAAb,KAAwB,CAA5B,EAA+B;AAC7B,cAAMiB,kBAAkBH,eAAef,KAAf,CAAqB,GAArB,CAAxB;AACA,cAAImB,aAAYF,aAAa,CAAb,IAAkBA,aAAa,CAAb,CAAlC;AACA;AACA,cAAIG,wBAAwBD,UAA5B;;AAEA;AACA,cAAIA,WAAUE,QAAV,CAAmB,GAAnB,CAAJ,EAA6B;AAC3B,gBAAMC,cAAcH,WAAUI,KAAV,CAAgB,CAAhB,EAAmBJ,WAAUK,OAAV,CAAkB,GAAlB,CAAnB,CAApB;AACA,gBAAMC,aAAaN,WAAUI,KAAV,CAAgBJ,WAAUK,OAAV,CAAkB,GAAlB,IAAyB,CAAzC,CAAnB;AACAJ,oCAAwBE,cAAcG,UAAtC;AACD;AACD,cACG,CAACN,WAAUE,QAAV,CAAmB,GAAnB,CAAD,IAA4BH,gBAAgB,CAAhB,EAAmBjB,MAAnB,GAA4BkB,WAAUlB,MAAnE,IACCkB,WAAUE,QAAV,CAAmB,GAAnB,KAA2BH,gBAAgB,CAAhB,EAAmBjB,MAAnB,GAA4BmB,sBAAsBnB,MAFhF,EAGE;AACA;AACAI,wBAAY,CAAZ;AACAS,2BAAeK,aAAY,GAAZ,GAAkBF,aAAa,CAAb,CAAjC;AACAE,yBAAYA,WAAUO,OAAV,CAAkB,IAAlB,EAAwB,EAAxB,CAAZ;AACA;AACA,gBAAIlD,gBAAgB2C,WAAUlB,MAAV,GAAmBzB,YAAvC,EAAqD;AACnDsC,6BAAeC,cAAf;AACD;AACF,WAZD,MAYO;AACLD,2BACEG,aAAa,CAAb,IAAkB,GAAlB,GAAwBA,aAAa,CAAb,CAAxB,GAA0CA,aAAa,CAAb,CAD5C;AAEA;AACA,gBAAIZ,WAAWc,WAAUlB,MAAV,GAAmB,CAAlC,EAAqC;AACnCI,0BAAY,CAAZ;AACD;AACF;AACF,SAhCD,MAgCO,IACLY,aAAahB,MAAb,KAAwB,CAAxB,IACAgB,aAAa,CAAb,MAAoB,EADpB,IAEAA,aAAa,CAAb,MAAoB,EAHf,EAIL;AACA;AACA;AACAH,yBAAe,UAAf;AACAT,qBAAW,CAAX,CAJA,CAIc;AACf,SATM,MASA,IAAI3C,UAAU,EAAd,EAAkB;AACvB;AACA;AACAoD,yBAAeC,cAAf;AACD;AACF;;AAED,UAAMY,wBAAwBjE,MAAMkE,SAAN,CAAgBvB,WAAW,CAA3B,EAA8BA,QAA9B,CAA9B;AACA,UAAIsB,0BAA0B,GAA9B,EAAmC;AACjC;AACAtB,oBAAY,CAAZ;AACD;;AAED,aAAO,CAAC,KAAKW,UAAL,CAAgBtD,KAAhB,CAAD,GACH,EAAEA,OAAOoD,YAAT,EAAuBT,kBAAvB,EADG,GAEH,EAAE3C,YAAF,EAAS2C,kBAAT,EAFJ;AAGD;;;kCAEawB,I,EAA2C;AACvD,UAAMnE,QAAQmE,KAAKnE,KAAnB;AACA,UAAI2C,WAAWwB,KAAKxB,QAApB;;AAEA;AACA,UAAI,CAAC3C,KAAL,EAAY;;AAEZ,UAAIyD,kBAAJ;AACA,UAAIW,iBAAJ;;AAEA,UAAID,KAAKnE,KAAL,CAAWuC,MAAX,GAAoB,CAApB,IAAyBvC,MAAMsC,KAAN,CAAY,GAAZ,EAAiBC,MAAjB,GAA0B,CAAvD,EAA0D;AACxD;AACAkB,oBAAYzD,MAAMkE,SAAN,CAAgB,CAAhB,EAAmBvB,QAAnB,KAAgC,GAA5C;AACAyB,mBAAWpE,MAAMkE,SAAN,CAAgBvB,QAAhB,EAA0B3C,MAAMuC,MAAhC,CAAX;AACD,OAJD,MAIO;AACL;AACA,YAAMgB,eAAevD,MAAMsC,KAAN,CAAY,GAAZ,CAArB;AACAmB,oBAAYF,aAAa,CAAb,IAAkBA,aAAa,CAAb,CAAlB,GAAoC,GAAhD;AACAa,mBAAWb,aAAa,CAAb,IAAkBA,aAAa,CAAb,CAAlB,GAAoC,QAA/C;AACD;;AAED;AACA,UAAIvD,MAAMqE,MAAN,CAAa,CAAb,MAAoB,GAApB,IAA2BC,SAASb,UAAUO,OAAV,CAAkB,IAAlB,EAAwB,EAAxB,CAAT,EAAsC,EAAtC,IAA4C,CAA3E,EAA8E;AAC5EP,oBAAYa,SAASb,UAAUO,OAAV,CAAkB,IAAlB,EAAwB,EAAxB,CAAT,EAAsC,EAAtC,CAAZ;AACA,YAAIrB,aAAa,CAAjB,EAAoB;AAClBA,qBAAW,CAAX;AACD,SAFD,MAEO;AACLA,qBAAW,CAAX;AACD;AACF,OAPD,MAOO,IAAI2B,SAASb,UAAUO,OAAV,CAAkB,IAAlB,EAAwB,EAAxB,CAAT,EAAsC,EAAtC,MAA8C,CAAlD,EAAqD;AAC1DP,oBAAYa,SAASb,UAAUO,OAAV,CAAkB,IAAlB,EAAwB,EAAxB,CAAT,EAAsC,EAAtC,CAAZ;AACD;;AAED,aAAO,EAAEhE,YAAF,EAAS2C,kBAAT,EAAmB4B,OAAO,EAAEd,oBAAF,EAAaW,kBAAb,EAA1B,EAAP;AACD;;AAED;;;;wCACoBD,I,EAOjB;AACD,UAAI,CAACA,IAAL,EAAW;;AADV,mBAGmE,KAAK3E,KAHxE;AAAA,UAGOqB,QAHP,UAGOA,QAHP;AAAA,UAGiB2D,QAHjB,UAGiBA,QAHjB;AAAA,UAG2BC,UAH3B,UAG2BA,UAH3B;AAAA,UAGuCC,UAHvC,UAGuCA,UAHvC;AAAA,UAGmD3D,WAHnD,UAGmDA,WAHnD;AAAA,UAIO4B,QAJP,GAIoBwB,IAJpB,CAIOxB,QAJP;;AAMD;;AACA,UAAMgC,+BAA+B,KAAKC,2BAAL,CAAiCT,IAAjC,CAArC;;AAEA;AACA;AACA,UAAMU,yBAAyBzC,WAAWuC,6BAA6BX,OAA7B,CAAqC,IAArC,EAA2C,EAA3C,CAAX,CAA/B;;AAEA;AACA,UAAIQ,YAAYK,yBAAyBL,QAAzC,EAAmD;AACjD,YAAMM,kBAAkBN,SAASO,OAAT,CAAiBhE,eAAe,CAAhC,EAAmCsB,QAAnC,EAAxB;AACA,aAAK7B,SAAL,wBAAoCsE,eAApC;;AAEA;AACA,YAAIL,UAAJ,EAAgB;AACd,eAAK9D,QAAL,CAAc,EAAEY,eAAeoB,QAAjB,EAAd;AACA,iBAAOmC,eAAP;AACD;AACH;AACC,OAVD,MAUO,IAAIjE,YAAYgE,yBAAyBhE,QAAzC,EAAmD;AACxD,YAAMmE,kBAAkBnE,SAASkE,OAAT,CAAiBhE,eAAe,CAAhC,EAAmCsB,QAAnC,EAAxB;AACA,aAAK7B,SAAL,wBAAoCwE,eAApC;;AAEA;AACA,YAAIN,UAAJ,EAAgB;AACd,eAAK/D,QAAL,CAAc,EAAEY,eAAeoB,QAAjB,EAAd;AACA,iBAAOqC,eAAP;AACD;AACD;AACD,OAVM,MAUA,IAAI,KAAK7E,KAAL,CAAWM,KAAX,KAAqB,EAAzB,EAA6B;AAClC,aAAKD,SAAL,CAAe,EAAf;AACD;;AAED;AACA,WAAKG,QAAL,CAAc,EAAEY,eAAeoB,QAAjB,EAAd;;AAEA;AACA;AACA,aAAOgC,4BAAP;AACD;;AAED;;;;gDAC4BR,I,EAOzB;AAAA,oBACqC,KAAK3E,KAD1C;AAAA,UACOsB,YADP,WACOA,YADP;AAAA,UACqBC,WADrB,WACqBA,WADrB;AAAA,UAEK0C,SAFL,GAEmBU,KAAKI,KAFxB,CAEKd,SAFL;AAAA,UAGKW,QAHL,GAGkBD,KAAKI,KAHvB,CAGKH,QAHL;;AAKD;AACA;;AACA,UAAItD,gBAAgB2C,SAApB,EAA+B;AAC7B;AACA,YAAMwB,iBACJnE,eAAe,CAAf,GAAmB,CAAnB,GACIwD,SAASxD,eAAe,CAAxB,EAA2B,EAA3B,CADJ,GAEIwD,SAASxD,eAAe,CAAxB,EAA2B,EAA3B,IAAiC,CAHvC;AAIA,YAAMoE,4BAA4BpE,eAAemE,cAAjD;AACA,YAAIxB,UAAUlB,MAAV,GAAmB2C,yBAAvB,EAAkD;AAChDzB,sBAAYA,UAAUS,SAAV,CAAoB,CAApB,EAAuBgB,yBAAvB,CAAZ;AACD;AACF;;AAED;AACA;AACAd,iBAAWA,SAASJ,OAAT,CAAiB,IAAjB,EAAuB,EAAvB,CAAX;AACA;AACA,UAAIjD,eAAeqD,QAAf,IAA2BA,SAAS7B,MAAT,GAAkBxB,WAAjD,EAA8D;AAC5DqD,mBAAWA,SAASF,SAAT,CAAmB,CAAnB,EAAsBnD,WAAtB,CAAX;AACD;;AAED;AACA,UAAIoE,iBAAiBf,WAAWA,SAAS7B,MAApB,GAA6B,CAAlD;AACA,UAAIxB,eAAeoE,iBAAiBpE,WAApC,EAAiD;AAC/C,aAAKoE,cAAL,EAAqBA,iBAAiBpE,WAAtC,EAAmDoE,gBAAnD,EAAqE;AACnEf,sBAAY,GAAZ;AACD;AACF;AACD;AACA,UAAIrD,gBAAgB,CAApB,EAAuB;AAAE,eAAO0C,SAAP;AAAmB;;AAE5C;AACA,aAAOA,YAAY,GAAZ,GAAkBW,QAAzB;AACD;;;8BAESpE,K,EAAe;AACvB,WAAKW,QAAL,CAAc,EAAEP,UAAUJ,KAAZ,EAAd;AACA;AACA,UAAIA,SAAS,CAACA,MAAM2D,QAAN,CAAe,GAAf,CAAd,EAAmC;AAAE,eAAO3D,KAAP;AAAe;AACpD,UAAI,CAACA,KAAL,EAAY;AAAE,aAAKW,QAAL,CAAc,EAAEa,iBAAiB,CAAnB,EAAd;AAAwC;AACtD,UAAIxB,KAAJ,EAAW;AACT,YAAMuD,eAAevD,MAAMsC,KAAN,CAAY,GAAZ,CAArB;AACA,YAAM8C,iBAAiB7B,aAAa,CAAb,EACpBS,OADoB,CACZ,IADY,EACN,EADM,EAEpB1B,KAFoB,CAEd,EAFc,EAGpB+C,OAHoB,GAIpBC,IAJoB,CAIf,EAJe,EAKpBtB,OALoB,CAKZ,YALY,EAKE,KALF,EAMpB1B,KANoB,CAMd,EANc,EAOpB+C,OAPoB,GAQpBC,IARoB,CAQf,EARe,CAAvB;AASA,YAAMC,qBAAqB,CAACH,eAAeI,KAAf,CAAqB,IAArB,KAA8B,EAA/B,EAAmCjD,MAA9D;AACA,aAAK5B,QAAL,CAAc,EAAEa,iBAAiB+D,kBAAnB,EAAd;AACA,eAAOH,iBAAiB,GAAjB,GAAuB7B,aAAa,CAAb,CAA9B;AACD;AACF;;;+BAEUvD,K,EAAe;AACxB,UAAMyF,gBAAgBzF,MAAMgE,OAAN,CAAc,IAAd,EAAoB,EAApB,CAAtB;AACA;AACA,aAAO,CAAC0B,MAAMtD,WAAWqD,aAAX,CAAN,CAAD,IAAqCE,SAASF,aAAT,CAA5C;AACD;;;6BAEQ;AACP;AADO,oBAcH,KAAKjG,KAdF;AAAA,UAGLoG,IAHK,WAGLA,IAHK;AAAA,UAIL3E,KAJK,WAILA,KAJK;AAAA,UAKLC,cALK,WAKLA,cALK;AAAA,UAMLzB,QANK,WAMLA,QANK;AAAA,UAOLgB,KAPK,WAOLA,KAPK;AAAA,UAQLG,OARK,WAQLA,OARK;AAAA,UASL4D,QATK,WASLA,QATK;AAAA,UAUL3D,QAVK,WAULA,QAVK;AAAA,UAWLC,YAXK,WAWLA,YAXK;AAAA,UAYLC,WAZK,WAYLA,WAZK;AAAA,UAaF8E,IAbE;;AAgBP,UAAMC,YAAYF,QAAQhF,QAAQmF,KAAR,CAAcC,cAAYC,KAA1B,CAA1B;;AAEA,aACE,8BAAC,SAAD;AACE,eAAOxF,SAAS,KAAKN,KAAL,CAAWM,KAD7B;AAEE,kBAAU,KAAKH,YAFjB;AAGE,kBAAU,KAAKb,QAHjB;AAIE,eAAO,KAAKU,KAAL,CAAWkB;AAJpB,SAKMwE,IALN,EADF;AASD;;;;EAvb4BK,gB;;AAAzB3G,gB,CAKG4G,W,GAAc,c;AALjB5G,gB,CAMG6G,Y,GAAe;AACpBxF,WAAS,oCADW;AAEpB6D,cAAY,KAFQ;AAGpBC,cAAY,KAHQ;AAIpB2B,YAAU,KAJU;AAKpBpF,SAAO,IALa;AAMpBD,WAASgF,cAAYC,KAND;AAOpB/E,kBAAgB,EAPI;AAQpBlB,SAAO;AARa,C;AAobjB,IAAMsG,sCAAe,0BAAU/G,gBAAV,CAArB","file":"NumericInput.js","sourcesContent":["// @flow\nimport React, { Component } from 'react';\n// $FlowFixMe\nimport type { ComponentType, SyntheticInputEvent, Element } from 'react';\n\n// external libraries\nimport createRef from 'create-react-ref/lib/createRef';\nimport { flow } from 'lodash';\n\n// internal utility functions\nimport { createEmptyContext, withTheme } from './HOC/withTheme';\nimport { composeTheme, addThemeId, didThemePropsChange } from '../utils/themes';\n\n// import constants\nimport { IDENTIFIERS } from '.';\nimport type { ThemeContextProp } from './HOC/withTheme';\n\ntype Props = {\n  autoFocus?: boolean,\n  className?: string,\n  context: ThemeContextProp,\n  disabled?: boolean,\n  enforceMax: boolean,\n  label?: string | Element<any>,\n  enforceMin: boolean,\n  error?: string,\n  onBlur?: Function,\n  onChange?: Function,\n  onFocus?: Function,\n  maxAfterDot?: number,\n  maxBeforeDot?: number,\n  maxValue?: number,\n  minValue?: number,\n  readOnly?: boolean,\n  placeholder?: string,\n  setError?: Function,\n  skin?: ComponentType<any>,\n  theme: ?Object, // will take precedence over theme in context if passed\n  themeId: string,\n  themeOverrides: Object,\n  value: string\n};\n\ntype State = {\n  composedTheme: Object,\n  caretPosition: number,\n  separatorsCount: number,\n  error: string,\n  oldValue: string\n};\n\nclass NumericInputBase extends Component<Props, State> {\n  // declare ref types\n  inputElement: Element<'input'>;\n\n  // define static properties\n  static displayName = 'NumericInput';\n  static defaultProps = {\n    context: createEmptyContext(),\n    enforceMax: false,\n    enforceMin: false,\n    readOnly: false,\n    theme: null,\n    themeId: IDENTIFIERS.INPUT,\n    themeOverrides: {},\n    value: ''\n  };\n\n  constructor(props: Props) {\n    super(props);\n    const { context, minValue, maxBeforeDot, maxAfterDot, themeId, theme, themeOverrides } = props;\n\n    const minValueIsNum = typeof minValue === 'number';\n    // if minValue is a number and user supplied maxBeforeDot and/or maxAfterDot\n    if (minValue && minValueIsNum && (maxBeforeDot || maxAfterDot)) {\n      // check combination of values for validity\n      this._validateLimitProps(minValue, maxBeforeDot, maxAfterDot);\n    }\n\n    // define ref\n    this.inputElement = createRef();\n\n    this.state = {\n      composedTheme: composeTheme(\n        addThemeId(theme || context.theme, themeId),\n        addThemeId(themeOverrides, themeId),\n        context.ROOT_THEME_API\n      ),\n      caretPosition: 0,\n      separatorsCount: 0,\n      error: '',\n      oldValue: ''\n    };\n  }\n\n  componentDidMount() {\n    const { inputElement } = this;\n    // check for autoFocus prop\n    if (this.props.autoFocus) this.focus();\n\n    // Set last input caret position on updates\n    if (inputElement && inputElement.current) {\n      this.setState({ caretPosition: inputElement.current.selectionStart });\n    }\n  }\n\n  componentWillReceiveProps(nextProps: Props) {\n    didThemePropsChange(this.props, nextProps, this.setState.bind(this));\n  }\n\n  componentDidUpdate(prevProps: Props, prevState: State) {\n    const { inputElement } = this;\n    if (inputElement && inputElement.current !== document.activeElement) { return; }\n\n    // caret position calculation after separators injection\n    let caretPosition;\n    // prevent unnecessary changes on re-rendering\n    if (\n      this.state.oldValue !== prevState.oldValue ||\n      this.state.caretPosition !== prevState.caretPosition\n    ) {\n      if (\n        this.state.separatorsCount !== prevState.separatorsCount &&\n        this.state.separatorsCount - prevState.separatorsCount <= 1 &&\n        this.state.separatorsCount - prevState.separatorsCount >= -1\n      ) {\n        caretPosition =\n          this.state.caretPosition +\n          (this.state.separatorsCount - prevState.separatorsCount);\n      } else {\n        caretPosition = this.state.caretPosition;\n      }\n      caretPosition = caretPosition >= 0 ? caretPosition : 0;\n\n      if (inputElement && inputElement.current) {\n        inputElement.current.selectionEnd = caretPosition;\n        inputElement.current.selectionStart = caretPosition;\n      }\n    }\n  }\n\n  onChange = (event: SyntheticInputEvent<Element<'input'>>) => {\n    event.preventDefault();\n    const { onChange, disabled } = this.props;\n    if (disabled) { return; }\n\n    // it is crucial to remove whitespace from input value\n    // with String.trim()\n    const processedValue = this._processValue(\n      event.target.value.trim(),\n      event.target.selectionStart\n    );\n\n    // if the processed value is the same, then the user probably entered\n    // invalid input such as nonnumeric characters, do not call onChange\n    if (processedValue === this.state.oldValue) { return; }\n\n    if (onChange) { onChange(processedValue, event); }\n  };\n\n  focus = () => {\n    const { inputElement } = this;\n    if (!inputElement.current) return;\n    inputElement.current.focus();\n  };\n\n  _validateLimitProps(minValue?: number, maxBeforeDot?: number, maxAfterDot?: number) {\n    if (typeof minValue !== 'number') return;\n    const maxBeforeDotIsNum = typeof maxBeforeDot === 'number';\n    const maxAfterDotIsNum = typeof maxAfterDot === 'number';\n    // if minValue is a float, it will split at the decimal\n    // trailing zeros are dropped with parseFloat\n    const minValParts = parseFloat(minValue).toString().split('.');\n\n    // if minValParts array has length of 2, it is a float\n    if (minValParts.length >= 2) {\n      const minValBeforeDot = minValParts[0];\n      const minValAfterDot = minValParts[1];\n\n      // if the number of integers in minValue is greater than maxBeforeDot\n      if (maxBeforeDot && maxBeforeDotIsNum && (minValBeforeDot.length > maxBeforeDot)) {\n        // the combo is incompatible, throw error\n        const error = `\n          minValue: ${minValue} exceeds the limit of maxBeforeDot: ${maxBeforeDot}.\n          Adjust the values of these properties.\n        `;\n        throw new Error(error);\n      // if the number of decimal spaces in minValue is greater than maxBeforeDot\n      } else if (maxAfterDot && maxAfterDotIsNum && (minValAfterDot.length > maxAfterDot)) {\n        const error = `\n          minValue: ${minValue} exceeds the limit of maxAfterDot: ${maxAfterDot}.\n          Adjust the values of these properties.\n        `;\n        throw new Error(error);\n      }\n    }\n  }\n\n  _setError = (error: string) => {\n    const { setError } = this.props;\n\n    // checks for setError func from FormField component\n    // if this NumericInput instance is rendered within FormField's render prop,\n    // FormField's local state.error will also be set via props.setError\n    if (setError) setError(error);\n    // also set (this: NumericInput)'s state.error\n    this.setState({ error });\n  };\n\n  _processValue(value: string, position: number) {\n    return flow([\n      this._enforceNumericValue,\n      this._parseToParts,\n      this._enforceValueLimits,\n      this._separate\n    ]).call(this, value, position);\n  }\n\n  _enforceNumericValue(value: string, position: number) {\n    const regex = /^[0-9.,]+$/;\n    const isValueRegular = regex.test(value);\n    const { maxBeforeDot } = this.props;\n    let handledValue;\n    const lastValidValue = this.state.oldValue;\n    if (!isValueRegular && value !== '') {\n      // input contains invalid value\n      // e.g. 1,00AAbasdasd.asdasd123123\n      // - reject it and show last valid value\n      handledValue = lastValidValue || '0.000000';\n      position -= 1;\n    } else if (!this._isNumeric(value)) {\n      // input contains comma separated number\n      // e.g. 1,000,000.123456\n      // - make sure commas and caret are at correct position\n      const splitedValue = value.split('.');\n\n      // check if input value contains more than one decimal\n      if (splitedValue.length === 3) {\n        const splitedOldValue = lastValidValue.split('.');\n        let beforeDot = splitedValue[0] + splitedValue[1];\n        // variable for value before the decimal containing a comma. Ex: 1,425\n        let beforeDotWithoutComma = beforeDot;\n\n        // if comma exists, remove before comparing length in next if-else statement\n        if (beforeDot.includes(',')) {\n          const beforeComma = beforeDot.slice(0, beforeDot.indexOf(','));\n          const afterComma = beforeDot.slice(beforeDot.indexOf(',') + 1);\n          beforeDotWithoutComma = beforeComma + afterComma;\n        }\n        if (\n          (!beforeDot.includes(',') && splitedOldValue[0].length < beforeDot.length) ||\n          (beforeDot.includes(',') && splitedOldValue[0].length < beforeDotWithoutComma.length)\n        ) {\n          // dot is in decimal part\n          position -= 1;\n          handledValue = beforeDot + '.' + splitedValue[2];\n          beforeDot = beforeDot.replace(/,/g, '');\n          // prevent replace dot if length before dot is greater then max before dot length\n          if (maxBeforeDot && beforeDot.length > maxBeforeDot) {\n            handledValue = lastValidValue;\n          }\n        } else {\n          handledValue =\n            splitedValue[0] + '.' + splitedValue[1] + splitedValue[2];\n          // Second dot was entered after current one -> stay in same position (swallow dot)\n          if (position > beforeDot.length + 1) {\n            position -= 1;\n          }\n        }\n      } else if (\n        splitedValue.length === 2 &&\n        splitedValue[0] === '' &&\n        splitedValue[1] === ''\n      ) {\n        // special case when dot is inserted in an empty input\n        // - return 0.|00000\n        handledValue = '0.000000';\n        position = 2; // position caret after the dot\n      } else if (value !== '') {\n        // special case when user selects part of an input value and hits ',' key\n        // - reject it and show last valid value\n        handledValue = lastValidValue;\n      }\n    }\n\n    const lastInsertedCharacter = value.substring(position - 1, position);\n    if (lastInsertedCharacter === ',') {\n      // prevent move caret position on hit ','\n      position -= 1;\n    }\n\n    return !this._isNumeric(value)\n      ? { value: handledValue, position }\n      : { value, position };\n  }\n\n  _parseToParts(data: { value: string, position: number }) {\n    const value = data.value;\n    let position = data.position;\n\n    // show placeholder on select all and delete/backspace key action\n    if (!value) return;\n\n    let beforeDot;\n    let afterDot;\n\n    if (data.value.length > 1 && value.split('.').length < 2) {\n      // handle numbers deletion from both integer and decimal parts at once\n      beforeDot = value.substring(0, position) || '0';\n      afterDot = value.substring(position, value.length);\n    } else {\n      // split float number to integer and decimal part - regular way\n      const splitedValue = value.split('.');\n      beforeDot = splitedValue[0] ? splitedValue[0] : '0';\n      afterDot = splitedValue[1] ? splitedValue[1] : '000000';\n    }\n\n    // remove leading zero and update caret position\n    if (value.charAt(0) === '0' && parseInt(beforeDot.replace(/,/g, ''), 10) > 0) {\n      beforeDot = parseInt(beforeDot.replace(/,/g, ''), 10);\n      if (position !== 2) {\n        position = 0;\n      } else {\n        position = 1;\n      }\n    } else if (parseInt(beforeDot.replace(/,/g, ''), 10) === 0) {\n      beforeDot = parseInt(beforeDot.replace(/,/g, ''), 10);\n    }\n\n    return { value, position, parts: { beforeDot, afterDot } };\n  }\n\n  // enforces props.maxValue and props.minValue\n  _enforceValueLimits(data: {\n    value: string,\n    position: number,\n    parts: {\n      beforeDot: string,\n      afterDot: string\n    }\n  }) {\n    if (!data) return;\n\n    const { minValue, maxValue, enforceMax, enforceMin, maxAfterDot } = this.props;\n    const { position } = data;\n\n    // enforce props.maxBeforeDot and props.maxAfterDot\n    const valueWithDecimalRestrictions = this._enforceDecimalRestrictions(data);\n\n    // creates floating point number equal to valueWithDecimalRestrictions (string)\n    // will be used for value comparisons against props.maxValue and props.minValue if applicable\n    const valueWithoutSeparators = parseFloat(valueWithDecimalRestrictions.replace(/,/g, ''));\n\n    // if input value is greater than props.maxValue, throw error\n    if (maxValue && valueWithoutSeparators > maxValue) {\n      const formattedMaxVal = maxValue.toFixed(maxAfterDot || 6).toString();\n      this._setError(`Maximum amount is ${formattedMaxVal}`);\n\n      // if user passes enforceMax=true, restrict input value to props.maxValue\n      if (enforceMax) {\n        this.setState({ caretPosition: position });\n        return formattedMaxVal;\n      }\n    // if input value is below props.minValue, throw error\n    } else if (minValue && valueWithoutSeparators < minValue) {\n      const formattedMinVal = minValue.toFixed(maxAfterDot || 6).toString();\n      this._setError(`Minimum amount is ${formattedMinVal}`);\n\n      // if props.enforceMin=true, restrict input value to props.minValue\n      if (enforceMin) {\n        this.setState({ caretPosition: position });\n        return formattedMinVal;\n      }\n      // if input value has no errors, clear state.error\n    } else if (this.state.error !== '') {\n      this._setError('');\n    }\n\n    // update caret in state\n    this.setState({ caretPosition: position });\n\n    // input value w/ decimal restrictions is passed along\n    // to this._separate without value restrictions\n    return valueWithDecimalRestrictions;\n  }\n\n  // enforces props.maxBeforeDot and props.maxAfterDot\n  _enforceDecimalRestrictions(data: {\n    value: string,\n    position: number,\n    parts: {\n      beforeDot: string,\n      afterDot: string\n    }\n  }) {\n    const { maxBeforeDot, maxAfterDot } = this.props;\n    let { beforeDot } = data.parts;\n    let { afterDot } = data.parts;\n\n    // preventing numbers with more than maxBeforeDot units\n    // - return first maxBeforeDot numbers (with comma separators)\n    if (maxBeforeDot && beforeDot) {\n      // max number of commas depending on max number of characters before dot\n      const numberOfCommas =\n        maxBeforeDot % 3 > 0\n          ? parseInt(maxBeforeDot / 3, 10)\n          : parseInt(maxBeforeDot / 3, 10) - 1;\n      const maxBeforeDotWithSeparator = maxBeforeDot + numberOfCommas;\n      if (beforeDot.length > maxBeforeDotWithSeparator) {\n        beforeDot = beforeDot.substring(0, maxBeforeDotWithSeparator);\n      }\n    }\n\n    // remove commas from decimal part\n    // (e.g. 123,23,2.002000 -> dot after 2.character reproduce 12.3,23,2)\n    afterDot = afterDot.replace(/,/g, '');\n    // preventing numbers with more than maxAfterDot units - return first maxAfterDot numbers\n    if (maxAfterDot && afterDot && afterDot.length > maxAfterDot) {\n      afterDot = afterDot.substring(0, maxAfterDot);\n    }\n\n    // if decimal number has less than maxAfterDot numbers add trailing zeros\n    let afterDotLength = afterDot ? afterDot.length : 0;\n    if (maxAfterDot && afterDotLength < maxAfterDot) {\n      for (afterDotLength; afterDotLength < maxAfterDot; afterDotLength++) {\n        afterDot += '0';\n      }\n    }\n    // if maxAfterDot is 0, drop decimal & numbers after decimal, return int\n    if (maxAfterDot === 0) { return beforeDot; }\n\n    // return input value w/decimal restrictions as a string\n    return beforeDot + '.' + afterDot;\n  }\n\n  _separate(value: string) {\n    this.setState({ oldValue: value });\n    // value will not contain '.' if maxAfterDot is 0, return early\n    if (value && !value.includes('.')) { return value; }\n    if (!value) { this.setState({ separatorsCount: 0 }); }\n    if (value) {\n      const splitedValue = value.split('.');\n      const separatedValue = splitedValue[0]\n        .replace(/,/g, '')\n        .split('')\n        .reverse()\n        .join('')\n        .replace(/(\\d{3}\\B)/g, '$1,')\n        .split('')\n        .reverse()\n        .join('');\n      const newSeparatorsCount = (separatedValue.match(/,/g) || []).length;\n      this.setState({ separatorsCount: newSeparatorsCount });\n      return separatedValue + '.' + splitedValue[1];\n    }\n  }\n\n  _isNumeric(value: string) {\n    const replacedValue = value.replace(/,/g, '');\n    // eslint-disable-next-line no-restricted-globals\n    return !isNaN(parseFloat(replacedValue)) && isFinite(replacedValue);\n  }\n\n  render() {\n    // destructuring props ensures only the \"...rest\" get passed down\n    const {\n      skin,\n      theme,\n      themeOverrides,\n      onChange,\n      error,\n      context,\n      maxValue,\n      minValue,\n      maxBeforeDot,\n      maxAfterDot,\n      ...rest\n    } = this.props;\n\n    const InputSkin = skin || context.skins[IDENTIFIERS.INPUT];\n\n    return (\n      <InputSkin\n        error={error || this.state.error}\n        inputRef={this.inputElement}\n        onChange={this.onChange}\n        theme={this.state.composedTheme}\n        {...rest}\n      />\n    );\n  }\n}\n\nexport const NumericInput = withTheme(NumericInputBase);\n"]}