{"version":3,"sources":["../../../source/components/HOC/withTheme.js"],"names":["withTheme","createEmptyContext","skins","theme","ROOT_THEME_API","Component","WrappedComponent","process","env","NODE_ENV","props","context","ref","displayName"],"mappings":";;;;;;;;;QAsBgBA,S,GAAAA,S;;AArBhB;;;;AAEA;;;;AACA;;AACA;;;;AAQO,IAAMC,kDAAqB,SAArBA,kBAAqB;AAAA,SAAyB;AACzDC,WAAO,EADkD;AAEzDC,WAAO,EAFkD;AAGzDC,oBAAgB;AAHyC,GAAzB;AAAA,CAA3B;;AAMP;AACA;AACA;AACO,SAASJ,SAAT,CAA0CK,SAA1C,EAA2D;AAChE,MAAIC,yBAAJ;;AAEA,MAAIC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,MAA7B,EAAqC;AACnC;AACAH,uBAAmB,0BAACI,KAAD;AAAA,aACjB;AAAC,kCAAD,CAAc,QAAd;AAAA;AACG;AAAA,iBAAW,8BAAC,SAAD,aAAW,SAASC,OAApB,IAAiCD,KAAjC,EAAX;AAAA;AADH,OADiB;AAAA,KAAnB;AAKD,GAPD,MAOO;AACL;AACAJ,uBAAmB,0BAAW,UAACI,KAAD,EAAYE,GAAZ;AAAA,aAC5B;AAAC,kCAAD,CAAc,QAAd;AAAA;AACG;AAAA,iBAAW,8BAAC,SAAD,aAAW,SAASD,OAApB,EAA6B,KAAKC,GAAlC,IAA2CF,KAA3C,EAAX;AAAA;AADH,OAD4B;AAAA,KAAX,CAAnB;AAKD;AACD;AACAJ,mBAAiBO,WAAjB,kBAA4C,2BAAeR,SAAf,CAA5C;AACA;AACA,SAASC,gBAAT;AACD","file":"withTheme.js","sourcesContent":["// @flow\nimport React from 'react';\nimport type { ComponentType, Ref } from 'react';\nimport forwardRef from 'create-react-ref/lib/forwardRef';\nimport { ThemeContext } from './ThemeContext';\nimport { getDisplayName } from '../../utils/props';\n\nexport type ThemeContextProp = {\n  skins: Object,\n  theme: Object,\n  ROOT_THEME_API: Object\n};\n\nexport const createEmptyContext = (): ThemeContextProp => ({\n  skins: {},\n  theme: {},\n  ROOT_THEME_API: {}\n});\n\n// withTheme is a HOC that takes a Component as a parameter\n// and returns that Component wrapped within ThemeContext.Consumer.\n// Any additional props and refs are forwarded to the returned Component.\nexport function withTheme<C: ComponentType<any>>(Component: C): C {\n  let WrappedComponent;\n\n  if (process.env.NODE_ENV === 'test') {\n    // wraps component in context only\n    WrappedComponent = (props: {}) => (\n      <ThemeContext.Consumer>\n        {context => <Component context={context} {...props} />}\n      </ThemeContext.Consumer>\n    );\n  } else {\n    // wraps component in context AND forwardRef\n    WrappedComponent = forwardRef((props: {}, ref: Ref<any>) => (\n      <ThemeContext.Consumer>\n        {context => <Component context={context} ref={ref} {...props} />}\n      </ThemeContext.Consumer>\n    ));\n  }\n  // create a new displayName for the wrapped component\n  WrappedComponent.displayName = `withTheme(${getDisplayName(Component)})`;\n  // Cast type to our desired custom component\n  return ((WrappedComponent: any): C);\n}\n"]}